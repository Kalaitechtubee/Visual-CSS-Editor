// CSS Generation Utilities

/**
 * Generate clean CSS from edited elements
 */
export function generateCSS(editedElements, options = {}) {
    const { minify = false, includeComments = true } = options;

    if (editedElements.length === 0) {
        return '/* No changes */';
    }

    let css = '';

    if (includeComments) {
        css += `/* Generated by Visual CSS Editor */\n`;
        css += `/* Date: ${new Date().toISOString()} */\n\n`;
    }

    editedElements.forEach((element, index) => {
        const { selector, newStyles } = element;

        if (!newStyles || Object.keys(newStyles).length === 0) return;

        // Group properties by category
        const categories = {
            typography: ['fontFamily', 'fontSize', 'fontWeight', 'lineHeight', 'letterSpacing', 'textAlign', 'color'],
            layout: ['display', 'justifyContent', 'alignItems', 'gap', 'flexDirection', 'flexWrap'],
            spacing: ['margin', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'padding', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft'],
            visual: ['backgroundColor', 'backgroundImage', 'opacity', 'borderRadius', 'boxShadow', 'mixBlendMode'],
            border: ['border', 'borderTop', 'borderRight', 'borderBottom', 'borderLeft', 'borderWidth', 'borderStyle', 'borderColor']
        };

        const styleLines = [];

        Object.entries(categories).forEach(([category, props]) => {
            const categoryStyles = [];

            props.forEach(prop => {
                if (newStyles[prop] !== undefined) {
                    const cssProperty = camelToKebab(prop);
                    categoryStyles.push(`  ${cssProperty}: ${newStyles[prop]};`);
                }
            });

            if (categoryStyles.length > 0 && includeComments) {
                styleLines.push(`  /* ${capitalize(category)} */`);
            }
            styleLines.push(...categoryStyles);
        });

        // Add remaining properties
        const usedProps = Object.values(categories).flat();
        Object.entries(newStyles).forEach(([prop, value]) => {
            if (!usedProps.includes(prop)) {
                styleLines.push(`  ${camelToKebab(prop)}: ${value};`);
            }
        });

        if (minify) {
            css += `${selector}{${styleLines.map(l => l.trim()).join('')}}`;
        } else {
            css += `${selector} {\n${styleLines.join('\n')}\n}`;
            if (index < editedElements.length - 1) css += '\n\n';
        }
    });

    return css;
}

/**
 * Generate design tokens from edited elements
 */
export function generateDesignTokens(editedElements) {
    const tokens = {
        colors: new Set(),
        fontFamilies: new Set(),
        fontSizes: new Set(),
        spacing: new Set(),
        borderRadius: new Set()
    };

    editedElements.forEach(({ newStyles }) => {
        if (!newStyles) return;

        // Colors
        if (newStyles.color) tokens.colors.add(newStyles.color);
        if (newStyles.backgroundColor) tokens.colors.add(newStyles.backgroundColor);
        if (newStyles.borderColor) tokens.colors.add(newStyles.borderColor);

        // Typography
        if (newStyles.fontFamily) tokens.fontFamilies.add(newStyles.fontFamily);
        if (newStyles.fontSize) tokens.fontSizes.add(newStyles.fontSize);

        // Spacing
        ['margin', 'padding'].forEach(prop => {
            ['Top', 'Right', 'Bottom', 'Left'].forEach(side => {
                const value = newStyles[`${prop}${side}`];
                if (value && value !== '0px') tokens.spacing.add(value);
            });
        });

        // Border Radius
        if (newStyles.borderRadius) tokens.borderRadius.add(newStyles.borderRadius);
    });

    // Generate CSS custom properties
    let css = ':root {\n';

    // Colors
    Array.from(tokens.colors).forEach((color, i) => {
        css += `  --color-${i + 1}: ${color};\n`;
    });

    // Font sizes
    Array.from(tokens.fontSizes).sort((a, b) => parseInt(a) - parseInt(b)).forEach((size, i) => {
        const names = ['xs', 'sm', 'base', 'lg', 'xl', '2xl', '3xl'];
        css += `  --text-${names[i] || i}: ${size};\n`;
    });

    // Spacing
    Array.from(tokens.spacing).sort((a, b) => parseInt(a) - parseInt(b)).forEach((space, i) => {
        css += `  --space-${i + 1}: ${space};\n`;
    });

    css += '}\n';

    return css;
}

/**
 * Convert camelCase to kebab-case
 */
function camelToKebab(str) {
    return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();
}

/**
 * Capitalize first letter
 */
function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

export default { generateCSS, generateDesignTokens };
